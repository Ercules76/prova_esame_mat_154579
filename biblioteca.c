#include <stdio.h>#include <stdlib.h>#include <string.h>#include "biblioteca.h"#include "utils.h"static int IDCliente = 1;cliente inserimento_nuovo_cliente(){    cls();    box(1, 2, 20, 80); // Grafica tabella generale    separator(5,2,80);    printStrAt(3, 32, "NUOVO CLIENTE");    cliente new_cliente;    printStrAt(7, 4, "Nome cliente:");    inputStrAt(7, 33, new_cliente.nome);    printStrAt(9, 4, "Cognome cliente:");    inputStrAt(9, 33, new_cliente.cognome);    printStrAt(11, 4, "Data di nascita [gg mm aaaa]");    inputDataAt(11, 33, new_cliente.data.giorno, new_cliente.data.mese, new_cliente.data.anno);    new_cliente.id = IDCliente;    return new_cliente;}int crea_elemento(lista_clienti **head, cliente _cliente) {    lista_clienti *nuovo_nodo;    if(nuovo_nodo = (lista_clienti *)malloc(sizeof(lista_clienti))) {        // se l'allocazione va a buon fine        strcpy(nuovo_nodo->val.clienti.nome, _cliente.nome);        strcpy(nuovo_nodo->val.clienti.cognome, _cliente.cognome);        strcpy(nuovo_nodo->val.clienti.data.giorno, _cliente.data.giorno);        strcpy(nuovo_nodo->val.clienti.data.mese, _cliente.data.mese);        strcpy(nuovo_nodo->val.clienti.data.anno, _cliente.data.anno);        nuovo_nodo->val.clienti.id =  _cliente.id;        nuovo_nodo->val.clienti.libri_posseduti = 0;        IDCliente++;        nuovo_nodo->next = NULL;    } else {        return MEMORY_FULL; // errore memoria full    }    if (*head == NULL) {        *head = nuovo_nodo;    } else {        nuovo_nodo->next = *head;        *head = nuovo_nodo;    }    return OK;}int cerca_se_cliente_ha_libro(int clientID, char isbn[MAX_LEN_ISBN], lista_prestiti *lista) {    lista_prestiti *tmp;    for(tmp = lista; tmp != NULL; tmp = tmp->next) {        if((tmp->val.prestito.codice_cliente == clientID) && (strcmp(isbn, tmp->val.prestito.isbn) == 0))            return OK;    }    return NOT_FOUND;}lista_libri *cerca_isbn_in_archivio(lista_libri *libri, char isbn[]) {    lista_libri *tmp = libri;    while((tmp != NULL) && (strcmp(tmp->val.libri.isbn, isbn) != 0))        tmp = tmp->next;    if(tmp != NULL)        return tmp;    return NULL;}libro inserimento_nuovo_libro(char isbn[]) {    cls();    box(1, 2, 20, 80); // Grafica tabella generale    separator(5,2,80);    printStrAt(3, 32, "NUOVO LIBRO");    libro new_libro;    int count, i;    strcpy(new_libro.isbn, isbn);    printStrAt(7,4, "Inserire titolo del libro:");    getchar();    fInputStrAt(7,33, new_libro.titolo);    printStrAt(9,4,"Quante copie ci sono?:");    inputIntAt(9,33, &new_libro.num_copie);    do {    printStrAt(11,4, "Quanti autori del libro ci sono? [MAX 3]: ");    inputIntAt(11,46, &count);    if(count > 3) {        printStrAt(13, 20, "ERRORE: Puoi inserire al più 3 autori:");        printStrAt(11, 46, " ");    }    }while(count > 3);    clsRow(13, 3, 80);    for(i = 0; i < count; i++) {        printStrAt(13 + 2 * i,4, "Inserire il nome dell' autore:");        inputStrAt(13 + 2 * i,38, new_libro.autori[i].nome);        printStrAt(14 + 2 * i,4, "Inserire il cognome dell' autore: ");        inputStrAt(14 + 2 * i,38, new_libro.autori[i].cognome);        new_libro.num_autori = i + 1;    }    return new_libro;}int inserimento_libro_in_lista(lista_libri **head, libro _libro){    lista_libri *nuovo_nodo;    int length = _libro.num_autori;    if(nuovo_nodo = (lista_libri *)malloc(sizeof(lista_libri))) {        // se l'allocazione va a buon fine        int i;        for(i = 0; i < length; i++) {            strcpy(nuovo_nodo->val.libri.autori[i].nome, _libro.autori[i].nome);            strcpy(nuovo_nodo->val.libri.autori[i].cognome, _libro.autori[i].cognome);        }        strcpy(nuovo_nodo->val.libri.titolo, _libro.titolo);        strcpy(nuovo_nodo->val.libri.isbn, _libro.isbn);        nuovo_nodo->val.libri.num_copie = _libro.num_copie;        nuovo_nodo->val.libri.num_autori = _libro.num_autori;        nuovo_nodo->next = NULL;    } else {        /* messaggio d'errore */        printf("Errore nell'allocare memoria per il dato\n");        return MEMORY_FULL; // Inserire errore memoria full    }    if (*head == NULL) {        *head = nuovo_nodo;    } else {        nuovo_nodo->next = *head;        *head = nuovo_nodo;    }    return OK;}void stampa_dati_libro(char isbn[], lista_libri *libro, int isError) {    cls();    int i;    box(1, 2, 20, 80);    if(isError == TRUE) {        printStrAt(2,35,"ATTENZIONE");        printf("\033[4;20HIl codice isbn %s è già presente in archivio.\n", isbn);    }    else        printf("\033[3;35HDATI LIBRO");    separator(5,2,80);    // UI per la stampa libro    printStrAt(8,4, "Titolo del libro:");    printStrAt(8,23,libro->val.libri.titolo);    printStrAt(10,4,"Autori:");    for(i = 0; i < libro->val.libri.num_autori; i++) {        printStrAt(11 + i,13,libro->val.libri.autori[i].nome);        printStrAt(11 + i,23,libro->val.libri.autori[i].cognome);    }    printStrAt(17,4,"Numero di copie presenti in libreria:");    printIntAt(17,43,libro->val.libri.num_copie);    ricarica_schermata();}void riepilogoPrestiti(lista_clienti *cliente, lista_libri *libro) {    cls();    box(1, 2, 20, 80);    printf("\033[3;33HRIEPILOGO PRESTITO");    separator(5,2,80);    printStrAt(8,4, "Nome:");    printStrAt(8,23,cliente->val.clienti.nome);    printStrAt(10, 4, "Cognome:");    printStrAt(10, 23, cliente->val.clienti.cognome);    printStrAt(12, 4, "Titolo Libro:");    printStrAt(12, 23, libro->val.libri.titolo);}lista_clienti *cerca_cliente_da_id(int id, lista_clienti *clienti) {    lista_clienti *tmp = clienti;    while((tmp != NULL) && (tmp->val.clienti.id != id))        tmp = tmp->next;    if(tmp != NULL)        return tmp;    return NULL;}void stampa_dati_cliente(lista_clienti *cliente, int isGlobalList) {    cls();    int i;    box(1, 2, 20, 80);    printf("\033[3;36HDATI CLIENTE");    separator(5,2,80);    // UI per la stampa libro    if(isGlobalList == TRUE) {        drawWall(6,20,40);    }    printStrAt(8,4, "Nome:");    printStrAt(8,23,cliente->val.clienti.nome);    printStrAt(10,4,"Cognome:");    printStrAt(10,23, cliente->val.clienti.cognome);    printStrAt(12,4,"Data:");    printStrAt(12,23,cliente->val.clienti.data.giorno);    printStrAt(12,26,cliente->val.clienti.data.mese);    printStrAt(12,29,cliente->val.clienti.data.anno);    printStrAt(14,4,"ID Cliente:");    printIntAt(14,23, cliente->val.clienti.id);}int inserimento_prestiti_in_lista(char isbn[], int clientId, lista_prestiti **head) {    cls();    box(1, 2, 20, 80);    printf("\033[3;36HDATI PRESTITO");    separator(5,2,80);    lista_prestiti *nuovo_nodo;    if(nuovo_nodo = (lista_prestiti*)malloc(sizeof(lista_prestiti))) {       strcpy(nuovo_nodo->val.prestito.isbn, isbn);        nuovo_nodo->val.prestito.codice_cliente = clientId;        printStrAt(8,4,"Data del prestito nel formato [gg mm aaaa]:");        inputDataAt(8,57,nuovo_nodo->val.prestito.data_prestito.giorno, nuovo_nodo->val.prestito.data_prestito.mese, nuovo_nodo->val.prestito.data_prestito.anno);        printStrAt(10,4,"Data del previsto rientro nel formato [gg mm aaaa]:");        inputDataAt(10,57,nuovo_nodo->val.prestito.data_consegna.giorno, nuovo_nodo->val.prestito.data_consegna.mese, nuovo_nodo->val.prestito.data_consegna.anno);        nuovo_nodo->val.prestito.isReturned = FALSE;        nuovo_nodo->next = NULL;    } else {        /* messaggio d'errore */        return MEMORY_FULL; // Inserire errore memoria full    }    if (*head == NULL) {        *head = nuovo_nodo;    } else {        nuovo_nodo->next = *head;        *head = nuovo_nodo;    }    return OK;}lista_prestiti *incrocia_dati(char isbn[], int clientId, lista_prestiti *head) {    lista_prestiti *tmp; // Puntatore scorri lista    for(tmp = head; tmp != NULL; tmp = tmp->next) {        if((strcmp(tmp->val.prestito.isbn, isbn) == 0) && (tmp->val.prestito.codice_cliente == clientId))            return tmp;    }    return NULL;}void inserimento_rientro_libro(lista_prestiti **head) {   lista_prestiti *tmp; // Puntatore scorri lista    tmp = *head;    printf("\033[22;2HInserire data rientro libro nel formato [gg mm aaaa]: ");    printf("\033[22;56H");    scanf("%s%s%s", tmp->val.prestito.data_rientro.giorno, tmp->val.prestito.data_rientro.mese, tmp->val.prestito.data_rientro.anno);    tmp->val.prestito.isReturned = TRUE;}void stampa_libro_in_prestito(int num_libri, int clientId, lista_prestiti *prestiti, lista_libri *libri) {    lista_prestiti *tmp_prestiti;    lista_libri *tmp_libri;    int i;    int count = 0;    char isbn[MAX_LEN_ISBN];    while(getchar() != '\n');    for(tmp_prestiti = prestiti; tmp_prestiti != NULL; tmp_prestiti = tmp_prestiti->next) {        if(tmp_prestiti->val.prestito.codice_cliente == clientId) {            strcpy(isbn, tmp_prestiti->val.prestito.isbn);            for(tmp_libri = libri; tmp_libri != NULL; tmp_libri = tmp_libri->next) {                if(strcmp(isbn, tmp_libri->val.libri.isbn) == 0) {                    pulizia_tabella();                    printStrAt(8,42,"Titolo:");                    printStrAt(8,51,tmp_libri->val.libri.titolo);                    printStrAt(9, 42, "Autori:");                    int index = tmp_libri->val.libri.num_autori;                    for(i = 0; i < index; i++) {                        printStrAt(10 + i, 51, tmp_libri->val.libri.autori[i].nome);                        printStrAt(10 + i, 61, tmp_libri->val.libri.autori[i].cognome);                    }                    printStrAt(14, 42,"Data Prestito:");                    printStrAt(14,68, tmp_prestiti->val.prestito.data_prestito.giorno);                    printStrAt(14, 70, "/");                    printStrAt(14,71, tmp_prestiti->val.prestito.data_prestito.mese);                    printStrAt(14, 73, "/");                    printStrAt(14,74, tmp_prestiti->val.prestito.data_prestito.anno);                    printStrAt(15, 42,"Data Prevista Rientro:");                    printStrAt(15,68, tmp_prestiti->val.prestito.data_consegna.giorno);                    printStrAt(15, 70, "/");                    printStrAt(15,71, tmp_prestiti->val.prestito.data_consegna.mese);                    printStrAt(15, 73, "/");                    printStrAt(15,74, tmp_prestiti->val.prestito.data_consegna.anno);                    if(tmp_prestiti->val.prestito.isReturned == TRUE) {                        printStrAt(16, 42,"Data Rientro Effettiva:");                        printStrAt(16,68, tmp_prestiti->val.prestito.data_rientro.giorno);                        printStrAt(16, 70, "/");                        printStrAt(16,71, tmp_prestiti->val.prestito.data_rientro.mese);                        printStrAt(16, 73, "/");                        printStrAt(16,74, tmp_prestiti->val.prestito.data_rientro.anno);                    }                    printf("\033[18;55HPagina (%d/%d)",++count, num_libri);                    getchar();                }            } // Fine stampa dati libro        }    }    ricarica_schermata();}int controlla_se_libro_in_prestito(char isbn[], lista_prestiti* lista) {    int count;    lista_prestiti* tmp;    for(tmp = lista; tmp != NULL; tmp = tmp->next) {        if(strcmp(isbn, tmp->val.prestito.isbn) == 0)            count++;    }    return count;}int rimuovi_cliente_da_lista(lista_clienti *cliente, lista_clienti **head) {    lista_clienti *tmp, *current = *head;    // Verifichiamo se il cliente è il primo della lista    if(*head == cliente) {        tmp = *head;        *head = (*head)->next;        free(tmp);        return OK;    }    while(current->next != cliente) // Verifichiamo se gli indirizzi sono uguali        current = current->next;    tmp = current->next; //Nodo da eliminare    current->next = tmp->next; // Collegamento nodo successivo al nodo precedente    free(tmp);    return 0;}int rimuovi_libro_da_lista(lista_libri *libro, lista_libri **head) {    lista_libri *tmp, *current = *head;    // Verifichiamo se il libro è il primo della lista    if(*head == libro) {        tmp = *head;        *head = (*head)->next;        free(tmp);        return OK;    }    while(current->next != libro) // Verifichiamo se gli indirizzi sono uguali        current = current->next;    tmp = current->next; //Nodo da eliminare    current->next = tmp->next; // Collegamento nodo successivo al nodo precedente    free(tmp);    return 0;}int rimuovi_libro_da_cliente(int clientID, char isbn[], lista_prestiti **head) {    lista_prestiti *tmp, *current = *head;    //Verificare    // Se la lista è vuota    // Verifichiamo se il libro è il primo della lista    if((*head)->val.prestito.codice_cliente == clientID && strcmp((*head)->val.prestito.isbn, isbn) == 0) {        tmp = *head;        *head = (*head)->next;        free(tmp);        return OK;    }    while((current->next->val.prestito.codice_cliente != clientID) || (strcmp(current->next->val.prestito.isbn, isbn) != 0)) // Verifichiamo se gli indirizzi sono uguali        current = current->next;    tmp = current->next; //Nodo da eliminare    current->next = tmp->next; // Collegamento nodo successivo al nodo precedente    free(tmp);    return 0;}void ricarica_schermata() {    while(getchar() != '\n');    printStrAt(22, 2, "Premere tasto invio per continuare...");    while(getchar() != '\n');}void pulizia_tabella() {    int k;    for(k = 8; k < 16; k++)        clsRow(k,42, 78);}void scelta_non_consentita(int menuID) {    clsRow(18,23,75);    if(menuID == MENU_0)        printStrAt(18, 30, "ATTENZIONE: Scelte consentite [0 - 8]");    else        printStrAt(18, 30, "ATTENZIONE: Scelte consentite [0 - 3]");}void cliente_non_trovato() {    warning();    printStrAt(18, 30, "ATTENZIONE: cliente non in archivio");}void libro_non_trovato() {    warning();    printStrAt(18, 30, "ATTENZIONE: libro non in archivio");}void cliente_non_in_possesso_del_libro() {    warning();    printStrAt(18, 25, "ATTENZIONE: Il cliente non possiede questo libro");}void data_rientro_non_consentita() {    warning();    printStrAt(18, 22, "ATTENZIONE: Il cliente non ha in consegna questo libro.");}void impossibile_eliminare_cliente() {    warning();    printStrAt(18, 22, "ATTENZIONE: Non è possibile eliminare il cliente.");    printStrAt(19, 31, "Il cliente è in possesso di alcuni libri.");}void impossibile_eliminare_libro(int copie) {    warning();    printStrAt(18, 22, "ATTENZIONE: Non è possibile eliminare il libro.");    if(copie > 1)        printf("\033[19;34Hci sono %d copie in prestito.", copie);    else        printf("\033[19;34Hc'è %d copia in prestito.", copie);}void caricamento_fallito() {    warning();    printStrAt(18, 25, "ATTENZIONE: Non tutte le liste sono state caricate");}void caricamento_ok() {    warning();    printStrAt(18, 22, "SUCCESS: Tutte le liste sono state caricate");}void warning() {    clsRow(18,23,75); // Pulisce messaggio di errore su schermo    clsRow(22,2,60); // Pulisce la riga di inserimento dati    printStrAt(18, 12, " ");}// Messaggi di operazione avvenuta con successovoid rimozione_avvenuta() {    warning();    printStrAt(18, 22, "SUCCESS: Rimozione avvenuta con successo.");}// Funzioni di debugvoid stampa_lista_clienti(lista_clienti* lista) {    cls();    lista_clienti *tmp;    int i = 5;    box(1, 2, 20, 80);    if(lista == NULL) {        printStrAt(10, 35, "LISTA VUOTA");        ricarica_schermata();        return;    }    printStrAt(3,20, "NOME:");    printStrAt(3,40, "COGNOME:");    printStrAt(3,60, "ID:");    for(tmp = lista; tmp != NULL; tmp = tmp->next) {        printStrAt(i, 15, tmp->val.clienti.nome);        printStrAt(i, 40, tmp->val.clienti.cognome);        printIntAt(i, 60, tmp->val.clienti.id);        i++;    }    ricarica_schermata();}void stampa_lista_libri(lista_libri *lista) {    cls();    lista_libri *tmp;    int i = 5;    box(1, 2, 20, 80);    if(lista == NULL) {        printStrAt(10, 35, "LISTA VUOTA");        ricarica_schermata();        return;    }    printStrAt(3,20, "TITOLO:");    printStrAt(3,40, "ISBN:");    printStrAt(3,55, "NUMERO COPIE:");    for(tmp = lista; tmp != NULL; tmp = tmp->next) {        printStrAt(i, 10, tmp->val.libri.titolo);        printStrAt(i, 40, tmp->val.libri.isbn);        printIntAt(i, 60, tmp->val.libri.num_copie);        i++;    }    ricarica_schermata();}// -------------------------- Funzioni gestione file su disco ------------------------// FUNZIONI DI SALVATAGGIO SU FILEvoid salva_lista_clienti(lista_clienti *lista) {    FILE *fp;    fp = fopen("clienti.dat", "wb");    if(fp != NULL) {        lista_clienti *tmp;        for(tmp = lista; tmp != NULL; tmp = tmp->next) {            fseek(fp, 0, SEEK_END);            fwrite(tmp, sizeof(lista_clienti), 1, fp);        }        fclose(fp);        fp = NULL;    }else{        // messaggio errore    }}void salva_lista_prestiti(lista_prestiti *lista) {    FILE *fp;    fp = fopen("prestiti.dat", "wb");    if(fp != NULL) {        lista_prestiti *tmp;        for(tmp = lista; tmp != NULL; tmp = tmp->next) {            fseek(fp, 0, SEEK_END);            fwrite(tmp, sizeof(lista_prestiti), 1, fp);        }        fclose(fp);        fp = NULL;    }else{        // messaggio errore    }}void salva_lista_libri(lista_libri *lista) {    FILE *fp;    fp = fopen("libri.dat", "wb");    if(fp != NULL) {        lista_libri *tmp;        for(tmp = lista; tmp != NULL; tmp = tmp->next) {            fseek(fp, 0, SEEK_END);            fwrite(tmp, sizeof(lista_libri), 1, fp);        }        fclose(fp);        fp = NULL;    }else{        // messaggio errore    }}// FUNZIONI DI CARICAMENTO DA FILEint carica_lista_clienti(lista_clienti **head) {    FILE *fp;    fp = fopen("clienti.dat", "r");    if(fp != NULL) {        int res;        *head = NULL; // Testa della lista, viene utilizzata solo per l'inizializzazione        lista_clienti *iterator, *tmp;        while (!feof(fp)) {            tmp = malloc(sizeof(lista_clienti));            res = fread(tmp, 1, (sizeof (lista_clienti)), fp);            if(res <= 0)                return OK;            tmp->next = NULL;            if(*head == NULL) {                *head = tmp;                iterator = tmp;            } else {                iterator->next = tmp;                iterator = iterator->next;            }        }    } else {        return FILE_NOT_FOUND;    }    fclose(fp);    fp = NULL;    return OK;}int carica_lista_libri(lista_libri **head) {    FILE *fp;    fp = fopen("libri.dat", "r");    if(fp != NULL) {        int res;        *head = NULL; // Testa della lista, viene utilizzata solo per l'inizializzazione        lista_libri *iterator, *tmp;        while (!feof(fp)) {            tmp = malloc(sizeof(lista_libri));            res = fread(tmp, 1, (sizeof (lista_libri)), fp);            if(res <= 0)                return OK;            tmp->next = NULL;            if(*head == NULL) {                *head = tmp;                iterator = tmp;            } else {                iterator->next = tmp;                iterator = iterator->next;            }        }    } else        return FILE_NOT_FOUND;    fclose(fp);    fp = NULL;    return OK;}int carica_lista_prestiti(lista_prestiti **head) {    FILE *fp;    fp = fopen("prestiti.dat", "r");    if(fp != NULL) {        int res;        *head = NULL; // Testa della lista, viene utilizzata solo per l'inizializzazione        lista_prestiti *iterator, *tmp;        while (!feof(fp)) {            tmp = malloc(sizeof(lista_prestiti));            res = fread(tmp, 1, (sizeof (lista_prestiti)), fp);            if(res <= 0)                return OK;            tmp->next = NULL;            if(*head == NULL) {                *head = tmp;                iterator = tmp;            } else {                iterator->next = tmp;                iterator = iterator->next;            }        }    } else        return FILE_NOT_FOUND;    fclose(fp);    fp = NULL;    return OK;}